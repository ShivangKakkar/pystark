{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyStark PyStark is a fast, easy-to-use tool for creating Telegram bots in Python that is completely powered by Pyrogram , one of the best MTProto Frameworks available. This documentation is designed primarily for absolute beginners, keeping in mind the specific needs of all major operating systems. Try out PyStark Not convinced to use PyStark? Try it out first, using few small steps given in the quick-start section. Quick Start - Overview to get you started quickly. How the Documentation is Organized Installation - Install pystark on your device. Boilerplate - Generate a boilerplate. Mandatory Variables - Set up the needed variables for bot. Customization - Easily customize your bot. Project Settings - Project settings. Creating Plugins - Code your own plugins Run Bot - Run your bot locally. Using Databases - Use various databases with PyStark. Querying Postgres Database - Use postgres with PyStark. Telegram as a Database - Use Telegram as a Database with PyStark. TinyDB - Use TinyDB as project database with PyStark. Bot Menu - Set Bot Menu using PyStark. Class Stark - The main class Stark. Command Decorator - The main decorator in pystark. Callback Decorator - Handle callback queries. Inline Decorator - Handle inline queries. Easy mantra to use this documentation Just tap on Next button below every page, keep reading while following the steps whenever necessary. That's it. Meta PyStark FAQs - Answer to common PyStark questions. ChangeLog - ChangeLog for PyStark releases.","title":"Home"},{"location":"#welcome-to-pystark","text":"PyStark is a fast, easy-to-use tool for creating Telegram bots in Python that is completely powered by Pyrogram , one of the best MTProto Frameworks available. This documentation is designed primarily for absolute beginners, keeping in mind the specific needs of all major operating systems.","title":"Welcome to PyStark"},{"location":"#try-out-pystark","text":"Not convinced to use PyStark? Try it out first, using few small steps given in the quick-start section. Quick Start - Overview to get you started quickly.","title":"Try out PyStark"},{"location":"#how-the-documentation-is-organized","text":"Installation - Install pystark on your device. Boilerplate - Generate a boilerplate. Mandatory Variables - Set up the needed variables for bot. Customization - Easily customize your bot. Project Settings - Project settings. Creating Plugins - Code your own plugins Run Bot - Run your bot locally. Using Databases - Use various databases with PyStark. Querying Postgres Database - Use postgres with PyStark. Telegram as a Database - Use Telegram as a Database with PyStark. TinyDB - Use TinyDB as project database with PyStark. Bot Menu - Set Bot Menu using PyStark. Class Stark - The main class Stark. Command Decorator - The main decorator in pystark. Callback Decorator - Handle callback queries. Inline Decorator - Handle inline queries.","title":"How the Documentation is Organized"},{"location":"#easy-mantra-to-use-this-documentation","text":"Just tap on Next button below every page, keep reading while following the steps whenever necessary. That's it.","title":"Easy mantra to use this documentation"},{"location":"#meta","text":"PyStark FAQs - Answer to common PyStark questions. ChangeLog - ChangeLog for PyStark releases.","title":"Meta"},{"location":"decorators/","text":"Available Decorators Decorators are a very helpful tool in Python. They make functions easily reusable anywhere. PyStark has some decorators to do the same. These are the decorators of class Stark to handle messages and queries: Stark.command - Handle a certain type of messages like command messages. Read More Here Stark.inline - Handle queries in inline mode. Read More Here Stark.callback - Handle callback queries (button clicks). Read More Here","title":"Available Decorators"},{"location":"decorators/#available-decorators","text":"Decorators are a very helpful tool in Python. They make functions easily reusable anywhere. PyStark has some decorators to do the same. These are the decorators of class Stark to handle messages and queries: Stark.command - Handle a certain type of messages like command messages. Read More Here Stark.inline - Handle queries in inline mode. Read More Here Stark.callback - Handle callback queries (button clicks). Read More Here","title":"Available Decorators"},{"location":"decorators/callback/","text":"Stark.callback Python decorator of class Stark to handle callback queries. Callback queries are the queries which originate when bot's button is clicked/tapped on. This decorator is used to handle callback queries. All arguments are optional. Parameters: Name Type Description Default query str | list[str] Query on which your function is called. Defaults to None, to handle all queries if your function handles all or if using 'filters' None startswith bool Set to True if you want your function to handle all queries starting with the query_string. Defaults to False. False owner_only bool Allow only owner to use this command. Defaults to False. False sudo_only bool Allow only sudos to use this command. Includes owner as sudo automatically. Defaults to False. False group int Define a group for this handler. Defaults to 0. Read More 0 filters pyrogram.filters Extra filters to apply in your function. Import filters from pyrogram or pystark to use this. See example below. None Examples: from pystark import Stark # The normal and easiest way. # Bot will execute function, if button with callback_data 'first_button' is pressed/clicked. @Stark . callback ( 'first_button' ) # Handle multiple callback queries in one function. Mainly used to show same result or do some other pythonic thing, like if-else loop. # Bot will execute same function, if 'first_button' or 'second_button' is pressed/clicked. @Stark . callback ([ 'first_button' , 'second_button' ]) # Function will only be triggered if owner presses the button, that is, the user whose id is set as OWNER_ID in environment variables. # Others will be ignored. @Stark . callback ( 'first_button' , owner_only = True ) # Function will only be triggered if sudo users or owner presses the button, that is, users set as SUDO_USERS or OWNER_ID in environment variables. # Others will be ignored. @Stark . callback ( 'first_button' , sudo_only = True ) # Filter/Handle all queries. # Use positive integer to execute after executing another function in default group that also filtered this query. @Stark . callback ( group = 1 ) # or Use negative integer to execute before executing another function in default group that also filtered this query. @Stark . callback ( group =- 1 ) # Don't use this as other functions that handle queries won't work. @Stark . callback () # Filter other type of queries using 'filters' argument. # Import filters from pyrogram or pystark. from pystark import filters # Filter only queries by 'StarkProgrammer' and 'Designatory'. @Stark . callback ( filters = filters . user ([ 'StarkProgrammer' , 'Designatory' ])) # Filter only queries done in 'StarkBotsChat' @Stark . callback ( filters = filters . chat ( 'StarkBotsChat' )) # Filter only queries ending with the word 'baby'. @Stark . callback ( filters = filters . regex ( r 'baby$' )) # Filter all queries with the word 'hello' AND which are done in 'StarkBotsChat'. @Stark . callback ( filters = filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . callback ( 'hello' , filters = filters . chat ( 'StarkBotsChat' )) # Filter all queries with the word 'bots' OR which are done in 'StarkBotsChat' @Stark . callback ( filters = filters . chat ( 'StarkBotsChat' ) | filters . regex ( 'hello' )) # Filter all queries with the word 'bots' BUT which are NOT done in 'StarkBotsChat' @Stark . callback ( filters =~ filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . callback ( filters = filters . regex ( 'hello' ) & ~ filters . chat ( 'StarkBotsChat' ))","title":"Stark.callback"},{"location":"decorators/callback/#starkcallback","text":"Python decorator of class Stark to handle callback queries. Callback queries are the queries which originate when bot's button is clicked/tapped on. This decorator is used to handle callback queries. All arguments are optional. Parameters: Name Type Description Default query str | list[str] Query on which your function is called. Defaults to None, to handle all queries if your function handles all or if using 'filters' None startswith bool Set to True if you want your function to handle all queries starting with the query_string. Defaults to False. False owner_only bool Allow only owner to use this command. Defaults to False. False sudo_only bool Allow only sudos to use this command. Includes owner as sudo automatically. Defaults to False. False group int Define a group for this handler. Defaults to 0. Read More 0 filters pyrogram.filters Extra filters to apply in your function. Import filters from pyrogram or pystark to use this. See example below. None Examples: from pystark import Stark # The normal and easiest way. # Bot will execute function, if button with callback_data 'first_button' is pressed/clicked. @Stark . callback ( 'first_button' ) # Handle multiple callback queries in one function. Mainly used to show same result or do some other pythonic thing, like if-else loop. # Bot will execute same function, if 'first_button' or 'second_button' is pressed/clicked. @Stark . callback ([ 'first_button' , 'second_button' ]) # Function will only be triggered if owner presses the button, that is, the user whose id is set as OWNER_ID in environment variables. # Others will be ignored. @Stark . callback ( 'first_button' , owner_only = True ) # Function will only be triggered if sudo users or owner presses the button, that is, users set as SUDO_USERS or OWNER_ID in environment variables. # Others will be ignored. @Stark . callback ( 'first_button' , sudo_only = True ) # Filter/Handle all queries. # Use positive integer to execute after executing another function in default group that also filtered this query. @Stark . callback ( group = 1 ) # or Use negative integer to execute before executing another function in default group that also filtered this query. @Stark . callback ( group =- 1 ) # Don't use this as other functions that handle queries won't work. @Stark . callback () # Filter other type of queries using 'filters' argument. # Import filters from pyrogram or pystark. from pystark import filters # Filter only queries by 'StarkProgrammer' and 'Designatory'. @Stark . callback ( filters = filters . user ([ 'StarkProgrammer' , 'Designatory' ])) # Filter only queries done in 'StarkBotsChat' @Stark . callback ( filters = filters . chat ( 'StarkBotsChat' )) # Filter only queries ending with the word 'baby'. @Stark . callback ( filters = filters . regex ( r 'baby$' )) # Filter all queries with the word 'hello' AND which are done in 'StarkBotsChat'. @Stark . callback ( filters = filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . callback ( 'hello' , filters = filters . chat ( 'StarkBotsChat' )) # Filter all queries with the word 'bots' OR which are done in 'StarkBotsChat' @Stark . callback ( filters = filters . chat ( 'StarkBotsChat' ) | filters . regex ( 'hello' )) # Filter all queries with the word 'bots' BUT which are NOT done in 'StarkBotsChat' @Stark . callback ( filters =~ filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . callback ( filters = filters . regex ( 'hello' ) & ~ filters . chat ( 'StarkBotsChat' ))","title":"Stark.callback"},{"location":"decorators/command/","text":"Stark.command The main python decorator of class Stark. This decorator is used to handle messages. Mainly used to create commands. All arguments are optional. You can also use the alias Stark.cmd instead of Stark.command . Parameters: Name Type Description Default cmd str | list[str] Command(s) that triggers your function. Defaults to None, which is helpful you only want to use extra_filters argument. None description str, optional Command description to create Bot Menu. Defaults to None. Read More None group int Define a group for this handler. Defaults to 0. Read More 0 owner_only bool Allow only owner to use this command. Defaults to False. False sudo_only bool Allow only sudos to use this command. Includes owner as sudo automatically. Defaults to False. False private_only bool Only handle messages for private chats. Bot will ignore messages in groups and channels. Defaults to False. False group_only bool Only handle messages for groups. Bot will ignore messages in private chats and channels. Defaults to False. False channel_only bool Only handle messages for channels. Bot will ignore messages in private chats and groups. Defaults to False. False extra_filters pyrogram.filters Extra filters to apply in your function. Import filters from pyrogram or pystark to use this. See example below. None Examples: from pystark import Stark # The normal way. Bot will reply to command ``/greet`` sent anywhere and by anyone. @Stark . command ( 'greet' , description = 'Greet the user' ) # or @Stark . cmd ( 'greet' , 'Greet the user' ) # Bot will reply only to owner, that is, the user whose id is set as OWNER_ID in environment variables. # Others will be ignored. @Stark . command ( 'greet' , owner_only = True ) # Bot will reply only to sudo users or owner, that is, users set as SUDO_USERS or OWNER_ID in environment variables. # Others will be ignored. @Stark . command ( 'greet' , sudo_only = True ) # Bot will reply only if message is sent in private chat (aka pm). # Messages in groups and channels will be ignored. @Stark . command ( 'greet' , private_only = True ) # Bot will reply only if message is sent in groups. # Messages in groups and private chats will be ignored. @Stark . command ( 'greet' , group_only = True ) # Bot will reply only if message is sent in channels. # Messages in private chats and groups will be ignored. @Stark . command ( 'greet' , channel_only = True ) # Filter all messages. # Use positive integer to execute after executing another function in default group that also filtered this message. @Stark . command ( group = 1 ) # or Use negative integer to execute before executing another function in default group that also filtered this message. @Stark . command ( group =- 1 ) # Don't use this as other functions won't work. @Stark . command () # Filter other type of messages using extra_filters. # Import filters from pyrogram or pystark. from pystark import filters # Filter only media messages. @Stark . command ( extra_filters = filters . media ) # Filter only text messages. @Stark . command ( extra_filters = filters . text ) # Filter only messages sent by 'StarkProgrammer'. @Stark . command ( extra_filters = filters . user ( 'StarkProgrammer' )) # Filter only messages sent in 'StarkBotsChat' @Stark . command ( extra_filters = filters . chat ( 'StarkBotsChat' )) # Filter only messages with the word 'baby'. @Stark . command ( extra_filters = filters . regex ( 'baby' )) # Filter all media messages sent by bots. @Stark . command ( extra_filters = filters . bot & filters . media ) # Filter all messages sent by bots except media messages. @Stark . command ( extra_filters = filters . bot & ~ filters . media ) # Filter either media messages or text messages. @Stark . command ( extra_filters = filters . text | filters . media )","title":"Stark.command"},{"location":"decorators/command/#starkcommand","text":"The main python decorator of class Stark. This decorator is used to handle messages. Mainly used to create commands. All arguments are optional. You can also use the alias Stark.cmd instead of Stark.command . Parameters: Name Type Description Default cmd str | list[str] Command(s) that triggers your function. Defaults to None, which is helpful you only want to use extra_filters argument. None description str, optional Command description to create Bot Menu. Defaults to None. Read More None group int Define a group for this handler. Defaults to 0. Read More 0 owner_only bool Allow only owner to use this command. Defaults to False. False sudo_only bool Allow only sudos to use this command. Includes owner as sudo automatically. Defaults to False. False private_only bool Only handle messages for private chats. Bot will ignore messages in groups and channels. Defaults to False. False group_only bool Only handle messages for groups. Bot will ignore messages in private chats and channels. Defaults to False. False channel_only bool Only handle messages for channels. Bot will ignore messages in private chats and groups. Defaults to False. False extra_filters pyrogram.filters Extra filters to apply in your function. Import filters from pyrogram or pystark to use this. See example below. None Examples: from pystark import Stark # The normal way. Bot will reply to command ``/greet`` sent anywhere and by anyone. @Stark . command ( 'greet' , description = 'Greet the user' ) # or @Stark . cmd ( 'greet' , 'Greet the user' ) # Bot will reply only to owner, that is, the user whose id is set as OWNER_ID in environment variables. # Others will be ignored. @Stark . command ( 'greet' , owner_only = True ) # Bot will reply only to sudo users or owner, that is, users set as SUDO_USERS or OWNER_ID in environment variables. # Others will be ignored. @Stark . command ( 'greet' , sudo_only = True ) # Bot will reply only if message is sent in private chat (aka pm). # Messages in groups and channels will be ignored. @Stark . command ( 'greet' , private_only = True ) # Bot will reply only if message is sent in groups. # Messages in groups and private chats will be ignored. @Stark . command ( 'greet' , group_only = True ) # Bot will reply only if message is sent in channels. # Messages in private chats and groups will be ignored. @Stark . command ( 'greet' , channel_only = True ) # Filter all messages. # Use positive integer to execute after executing another function in default group that also filtered this message. @Stark . command ( group = 1 ) # or Use negative integer to execute before executing another function in default group that also filtered this message. @Stark . command ( group =- 1 ) # Don't use this as other functions won't work. @Stark . command () # Filter other type of messages using extra_filters. # Import filters from pyrogram or pystark. from pystark import filters # Filter only media messages. @Stark . command ( extra_filters = filters . media ) # Filter only text messages. @Stark . command ( extra_filters = filters . text ) # Filter only messages sent by 'StarkProgrammer'. @Stark . command ( extra_filters = filters . user ( 'StarkProgrammer' )) # Filter only messages sent in 'StarkBotsChat' @Stark . command ( extra_filters = filters . chat ( 'StarkBotsChat' )) # Filter only messages with the word 'baby'. @Stark . command ( extra_filters = filters . regex ( 'baby' )) # Filter all media messages sent by bots. @Stark . command ( extra_filters = filters . bot & filters . media ) # Filter all messages sent by bots except media messages. @Stark . command ( extra_filters = filters . bot & ~ filters . media ) # Filter either media messages or text messages. @Stark . command ( extra_filters = filters . text | filters . media )","title":"Stark.command"},{"location":"decorators/inline/","text":"Stark.inline Python decorator of class Stark to handle inline queries. This decorator is used to handle inline queries. All arguments are optional. Parameters: Name Type Description Default query str | list[str] Query on which your function is called. Pass a list to handle multiple queries. Defaults to None, to handle all queries if your function handles all or if you are using other 'filters' None startswith bool Set to True if you want your function to handle all queries starting with the 'query' string passed. Defaults to False. False owner_only bool Allow only owner to use this command. Defaults to False. False sudo_only bool Allow only sudos to use this command. Includes owner as sudo automatically. Defaults to False. False group int Define a group for this handler. Defaults to 0. Read More 0 filters pyrogram.filters Extra filters to apply in your function. Import filters from pyrogram or pystark to use this. See example below. None Examples: from pystark import Stark # The normal and easiest way. # Bot will show results / execute function, if 'hello' is searched by anyone. @Stark . inline ( 'hello' ) # Handle multiple inline queries in one function. Mainly used to execute same function or do some other pythonic thing, like if-else loop. # Bot will show results / execute function, if 'hello' or 'hey' is searched by anyone. @Stark . inline ([ 'hello' , 'hey' ]) # Function will only be triggered if owner searches 'hello', that is, the user whose id is set as OWNER_ID in environment variables. # Others will be ignored. @Stark . inline ( 'hello' , owner_only = True ) # Function will only be triggered if sudo users or owner searches 'hello', that is, users set as SUDO_USERS or OWNER_ID in environment variables. # Others will be ignored. @Stark . inline ( 'hello' , sudo_only = True ) # Filter/Handle all queries. # Use positive integer to execute after executing another function in default group that also filtered this query. @Stark . inline ( group = 1 ) # or Use negative integer to execute before executing another function in default group that also filtered this query. @Stark . inline ( group =- 1 ) # Don't use this as other functions that handle queries won't work. @Stark . inline () # Filter other type of queries using 'filters' argument. # Import filters from pyrogram or pystark. from pystark import filters # Filter only queries by 'StarkProgrammer' and 'Designatory'. @Stark . inline ( filters = filters . user ([ 'StarkProgrammer' , 'Designatory' ])) # Filter only queries done in 'StarkBotsChat' @Stark . inline ( filters = filters . chat ( 'StarkBotsChat' )) # Filter only queries ending with the word 'baby'. @Stark . inline ( filters = filters . regex ( r 'baby$' )) # Filter all queries with the word 'hello' AND which are done in 'StarkBotsChat'. @Stark . inline ( filters = filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . inline ( 'hello' , filters = filters . chat ( 'StarkBotsChat' )) # Filter all queries with the word 'bots' OR which are done in 'StarkBotsChat' @Stark . inline ( filters = filters . chat ( 'StarkBotsChat' ) | filters . regex ( 'hello' )) # Filter all queries with the word 'bots' BUT which are NOT done in 'StarkBotsChat' @Stark . inline ( filters =~ filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . inline ( filters = filters . regex ( 'hello' ) & ~ filters . chat ( 'StarkBotsChat' ))","title":"Stark.inline"},{"location":"decorators/inline/#starkinline","text":"Python decorator of class Stark to handle inline queries. This decorator is used to handle inline queries. All arguments are optional. Parameters: Name Type Description Default query str | list[str] Query on which your function is called. Pass a list to handle multiple queries. Defaults to None, to handle all queries if your function handles all or if you are using other 'filters' None startswith bool Set to True if you want your function to handle all queries starting with the 'query' string passed. Defaults to False. False owner_only bool Allow only owner to use this command. Defaults to False. False sudo_only bool Allow only sudos to use this command. Includes owner as sudo automatically. Defaults to False. False group int Define a group for this handler. Defaults to 0. Read More 0 filters pyrogram.filters Extra filters to apply in your function. Import filters from pyrogram or pystark to use this. See example below. None Examples: from pystark import Stark # The normal and easiest way. # Bot will show results / execute function, if 'hello' is searched by anyone. @Stark . inline ( 'hello' ) # Handle multiple inline queries in one function. Mainly used to execute same function or do some other pythonic thing, like if-else loop. # Bot will show results / execute function, if 'hello' or 'hey' is searched by anyone. @Stark . inline ([ 'hello' , 'hey' ]) # Function will only be triggered if owner searches 'hello', that is, the user whose id is set as OWNER_ID in environment variables. # Others will be ignored. @Stark . inline ( 'hello' , owner_only = True ) # Function will only be triggered if sudo users or owner searches 'hello', that is, users set as SUDO_USERS or OWNER_ID in environment variables. # Others will be ignored. @Stark . inline ( 'hello' , sudo_only = True ) # Filter/Handle all queries. # Use positive integer to execute after executing another function in default group that also filtered this query. @Stark . inline ( group = 1 ) # or Use negative integer to execute before executing another function in default group that also filtered this query. @Stark . inline ( group =- 1 ) # Don't use this as other functions that handle queries won't work. @Stark . inline () # Filter other type of queries using 'filters' argument. # Import filters from pyrogram or pystark. from pystark import filters # Filter only queries by 'StarkProgrammer' and 'Designatory'. @Stark . inline ( filters = filters . user ([ 'StarkProgrammer' , 'Designatory' ])) # Filter only queries done in 'StarkBotsChat' @Stark . inline ( filters = filters . chat ( 'StarkBotsChat' )) # Filter only queries ending with the word 'baby'. @Stark . inline ( filters = filters . regex ( r 'baby$' )) # Filter all queries with the word 'hello' AND which are done in 'StarkBotsChat'. @Stark . inline ( filters = filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . inline ( 'hello' , filters = filters . chat ( 'StarkBotsChat' )) # Filter all queries with the word 'bots' OR which are done in 'StarkBotsChat' @Stark . inline ( filters = filters . chat ( 'StarkBotsChat' ) | filters . regex ( 'hello' )) # Filter all queries with the word 'bots' BUT which are NOT done in 'StarkBotsChat' @Stark . inline ( filters =~ filters . chat ( 'StarkBotsChat' ) & filters . regex ( 'hello' )) # or @Stark . inline ( filters = filters . regex ( 'hello' ) & ~ filters . chat ( 'StarkBotsChat' ))","title":"Stark.inline"},{"location":"introduction/install/","text":"Installation This guide will show you how to install PyStark. Be sure to keep an eye out for new releases and keep upgrading the library. Installing PyStark PyStark is available on PyPI, and its latest stable version can be installed using pip: $ pip3 install pystark Using Beta Version Note Features are almost always released as soon as they have been committed and checked. So there will be little difference even if the package is installed with pip. When you install from the git master branch, you will be able to install the beta versions of the new features. You can do that using this command: $ pip install git+https://github.com/StarkBotsIndustries/pystark.git Upgrading pre-installed PyStark Being a new library, we keep updating PyStark. You can check for new releases on PyPI. Thus, you will be able to use new features of PyStark. Here's how to upgrade, if you have pre-installed PyStark: $ pip install --upgrade pystark","title":"Installation"},{"location":"introduction/install/#installation","text":"This guide will show you how to install PyStark. Be sure to keep an eye out for new releases and keep upgrading the library.","title":"Installation"},{"location":"introduction/install/#installing-pystark","text":"PyStark is available on PyPI, and its latest stable version can be installed using pip: $ pip3 install pystark","title":"Installing PyStark"},{"location":"introduction/install/#using-beta-version","text":"Note Features are almost always released as soon as they have been committed and checked. So there will be little difference even if the package is installed with pip. When you install from the git master branch, you will be able to install the beta versions of the new features. You can do that using this command: $ pip install git+https://github.com/StarkBotsIndustries/pystark.git","title":"Using Beta Version"},{"location":"introduction/install/#upgrading-pre-installed-pystark","text":"Being a new library, we keep updating PyStark. You can check for new releases on PyPI. Thus, you will be able to use new features of PyStark. Here's how to upgrade, if you have pre-installed PyStark: $ pip install --upgrade pystark","title":"Upgrading pre-installed PyStark"},{"location":"introduction/quickstart/","text":"Quick Start Following these steps will allow you to see PyStark in action as quickly as possible. Note Installation of Python with version 3.6 or above is required. Steps 1. Open up your terminal . 2. Install PyStark with pip $ pip3 install pystark 3. Generate a boilerplate using PyStark's command-line tool. $ pystark --boilerplate 4. Enter the newly created boilerplate directory. $ cd boilerplate 5. Open the file manager in current directory . 6. Edit the .env file and fill your API_ID , API_HASH and BOT_TOKEN . Get the API keys from my.telegram.org and bot token from BotFather . 7. Run the bot using python $ python3 bot.py What does this do? The above steps will help you set up your bot and run it. You can use the command /start to check if your bot is actually running. Your bot now has four default commands: /start - Start the bot. /help - See a help message for the bot. /about - About the bot. /id - Get Telegram ID (also works in groups) Stop the bot using Ctrl+C .","title":"Quick Start"},{"location":"introduction/quickstart/#quick-start","text":"Following these steps will allow you to see PyStark in action as quickly as possible. Note Installation of Python with version 3.6 or above is required.","title":"Quick Start"},{"location":"introduction/quickstart/#steps","text":"1. Open up your terminal . 2. Install PyStark with pip $ pip3 install pystark 3. Generate a boilerplate using PyStark's command-line tool. $ pystark --boilerplate 4. Enter the newly created boilerplate directory. $ cd boilerplate 5. Open the file manager in current directory . 6. Edit the .env file and fill your API_ID , API_HASH and BOT_TOKEN . Get the API keys from my.telegram.org and bot token from BotFather . 7. Run the bot using python $ python3 bot.py","title":"Steps"},{"location":"introduction/quickstart/#what-does-this-do","text":"The above steps will help you set up your bot and run it. You can use the command /start to check if your bot is actually running. Your bot now has four default commands: /start - Start the bot. /help - See a help message for the bot. /about - About the bot. /id - Get Telegram ID (also works in groups) Stop the bot using Ctrl+C .","title":"What does this do?"},{"location":"meta/changelog/","text":"Changelog Latest Version: v1.0.1 v1.0.0 - April 6, 2022 Fix broken CLI due to bad imports. Add dev-requirement.txt for docs and pypi v1.0.0 - April 6, 2022 Enhanced project settings, inspired from django. Added brand new addons for additional features in bots. Brand-new documentation using Mkdocs instead of Sphinx. Database migration methods for pystark.database.sql.Database class like add_column , remove_column , etc. Added other useful methods like Improved boilerplate in favour of new features. Added documentation for project settings using settings.py Removed customization options from Stark.activate() as they can be configured using settings.py now. Removed pystark.database.postgres in favour of pystark.database.sql . Added sudo users support for bots which can be set using SUDO_USERS environment variable. Allow username as OWNER_ID instead of only user_id Pre-made models for users and bans table. And much, much more! v0.4.0 - March 15, 2022 BugFixes and improvements in SQL helper functions. Make Database related dependencies optional and automated. Class Database instead of functions Rollback at exceptions Raw SQL for getting all rows as it usually depends on python class instead of data in table Raise TableNotFound if it doesn't exist instead of returning None Rename pystark.databases.postgres to pystark.databased.sql in favour of other sql databases. Allow other type of Database URls Add attributes like session , base , engine to Database. v0.3.0 - January 28, 2022 Additions Use inline mode and callback buttons more easily. Handle inline queries using Stark.inline() . Handle callback queries using Stark.callback() . Load plugins from multiple directories. Instead of passing a 'str' to 'activate()' function, pass a list. Allow passing other keyword arguments while creating bot client. Override the in-built/default plugins automatically as they are loaded later now. PyStark CLI Added optional argument ['-v', '--version'] to see currently installed version. Removed optional argument ['-h', '--help'] as passing no argument does the same thing. Made unnecessary arguments private. Improvements Improved PyPI Home page and Project Readme. Improved Boilerplate. Upgraded TelegramDB. Separated constants. Renamed default plugins file to remove confusion. BugFixes Fixed ModuleNotFoundError for psycopg2 (missing requirement). Documentation Added documentation for all decorators . Stark.callback and Stark.inline Added a temporary logo. Thanks to Designatory . Removed dark mode. Separated older releases. Can be found here . Enable Single Version option. Changed the color for annoying visited links. Changed templates for footer and header. Add homepage to toctree. Custom 404 page. Thanks to Designatory . Other Improvements.","title":"Changelog"},{"location":"meta/changelog/#changelog","text":"Latest Version: v1.0.1","title":"Changelog"},{"location":"meta/changelog/#v100-april-6-2022","text":"Fix broken CLI due to bad imports. Add dev-requirement.txt for docs and pypi","title":"v1.0.0 - April 6, 2022"},{"location":"meta/changelog/#v100-april-6-2022_1","text":"Enhanced project settings, inspired from django. Added brand new addons for additional features in bots. Brand-new documentation using Mkdocs instead of Sphinx. Database migration methods for pystark.database.sql.Database class like add_column , remove_column , etc. Added other useful methods like Improved boilerplate in favour of new features. Added documentation for project settings using settings.py Removed customization options from Stark.activate() as they can be configured using settings.py now. Removed pystark.database.postgres in favour of pystark.database.sql . Added sudo users support for bots which can be set using SUDO_USERS environment variable. Allow username as OWNER_ID instead of only user_id Pre-made models for users and bans table. And much, much more!","title":"v1.0.0 - April 6, 2022"},{"location":"meta/changelog/#v040-march-15-2022","text":"BugFixes and improvements in SQL helper functions. Make Database related dependencies optional and automated. Class Database instead of functions Rollback at exceptions Raw SQL for getting all rows as it usually depends on python class instead of data in table Raise TableNotFound if it doesn't exist instead of returning None Rename pystark.databases.postgres to pystark.databased.sql in favour of other sql databases. Allow other type of Database URls Add attributes like session , base , engine to Database.","title":"v0.4.0 - March 15, 2022"},{"location":"meta/changelog/#v030-january-28-2022","text":"Additions Use inline mode and callback buttons more easily. Handle inline queries using Stark.inline() . Handle callback queries using Stark.callback() . Load plugins from multiple directories. Instead of passing a 'str' to 'activate()' function, pass a list. Allow passing other keyword arguments while creating bot client. Override the in-built/default plugins automatically as they are loaded later now. PyStark CLI Added optional argument ['-v', '--version'] to see currently installed version. Removed optional argument ['-h', '--help'] as passing no argument does the same thing. Made unnecessary arguments private. Improvements Improved PyPI Home page and Project Readme. Improved Boilerplate. Upgraded TelegramDB. Separated constants. Renamed default plugins file to remove confusion. BugFixes Fixed ModuleNotFoundError for psycopg2 (missing requirement). Documentation Added documentation for all decorators . Stark.callback and Stark.inline Added a temporary logo. Thanks to Designatory . Removed dark mode. Separated older releases. Can be found here . Enable Single Version option. Changed the color for annoying visited links. Changed templates for footer and header. Add homepage to toctree. Custom 404 page. Thanks to Designatory . Other Improvements.","title":"v0.3.0 - January 28, 2022"},{"location":"meta/faqs/","text":"Frequently Asked Questions What is PyStark? PyStark is a spoon-feeding library based on Pyrogram. Pyrogram is a spoon-feeding MTProto Framework made in Python. Python is a spoon-feeding programming language. Where to run commands? This means that you are an absolute beginner. If you are using Windows , tap on Start button and search for cmd or Command Prompt . If you are using MacOS or Linux`, search for Terminal . How to open file manager in current directory? For Windows use the start command: $ start . For MacOS use the open command: $ open . For Linux use the xdg-open command: $ xdg-open . The dot (.) after command is required to open in current directory. Where to learn Python ? There are tons of websites and free video tutorials to learn Python. But here's what I'll recommend you: English Code With Mosh [ recommended ] - Learn Python in 6 hrs or Learn Python in 1 hr (This is all you really need) Corey Schafer - Python Detailed Playlist w3schools - Web Tutorial freeCodeCamp - YouTube Tutorial Hindi Code With Harry [ recommended ] - Complete Python Course with Hindi notes","title":"FAQ"},{"location":"meta/faqs/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"meta/faqs/#what-is-pystark","text":"PyStark is a spoon-feeding library based on Pyrogram. Pyrogram is a spoon-feeding MTProto Framework made in Python. Python is a spoon-feeding programming language.","title":"What is PyStark?"},{"location":"meta/faqs/#where-to-run-commands","text":"This means that you are an absolute beginner. If you are using Windows , tap on Start button and search for cmd or Command Prompt . If you are using MacOS or Linux`, search for Terminal .","title":"Where to run commands?"},{"location":"meta/faqs/#how-to-open-file-manager-in-current-directory","text":"For Windows use the start command: $ start . For MacOS use the open command: $ open . For Linux use the xdg-open command: $ xdg-open . The dot (.) after command is required to open in current directory.","title":"How to open file manager in current directory?"},{"location":"meta/faqs/#where-to-learn-python","text":"There are tons of websites and free video tutorials to learn Python. But here's what I'll recommend you: English Code With Mosh [ recommended ] - Learn Python in 6 hrs or Learn Python in 1 hr (This is all you really need) Corey Schafer - Python Detailed Playlist w3schools - Web Tutorial freeCodeCamp - YouTube Tutorial Hindi Code With Harry [ recommended ] - Complete Python Course with Hindi notes","title":"Where to learn Python ?"},{"location":"meta/older-releases/","text":"Older Releases Note These are the changelog for older versions. Latest Version is 1.0.0 Please see the changelog for latest versions v0.2.11 - January 22, 2022 Use TinyDB for your project. Read More About It . v0.2.10 - January 22, 2022 Use Telegram as a Database. Read More About It . v0.2.9 - January 21, 2022 Fix Bugs of v0.2.8 v0.2.8 - January 21, 2022 Renamed argument private to private_only in command decorator. Added two new arguments group_only and channel_only in command decorator. Added docs for command decorator. See Here v0.2.7 - January 21, 2022 Auto Update Bot Menu at runtime. Read More Added description argument in command decorator(for bot menu). Stark.data() now also returns a dictionary of command descriptions (key=command, value=description). See Stark.data Stark.activate now takes an optional argument set_menu to disable (or enable) auto-update of bot menu. Read More Added docs for Bot Menu. Read Here v0.2.6 - January 20, 2022 Added two new static methods to Stark class - Stark.list_args and Stark.data() Improved Stark.log() function. Now pass int values for levels. See Stark.log Added docs for class Stark - Read Here v0.2.5 - January 20, 2022 Added in-built functions to query postgres tables - Read More Added ChangeLog to docs (this webpage) Improve documentation using sphinx-toolbox v0.2.4 - January 17, 2022 This Documentation was created","title":"Older Releases"},{"location":"meta/older-releases/#older-releases","text":"Note These are the changelog for older versions. Latest Version is 1.0.0 Please see the changelog for latest versions","title":"Older Releases"},{"location":"meta/older-releases/#v0211-january-22-2022","text":"Use TinyDB for your project. Read More About It .","title":"v0.2.11 - January 22, 2022"},{"location":"meta/older-releases/#v0210-january-22-2022","text":"Use Telegram as a Database. Read More About It .","title":"v0.2.10 - January 22, 2022"},{"location":"meta/older-releases/#v029-january-21-2022","text":"Fix Bugs of v0.2.8","title":"v0.2.9 - January 21, 2022"},{"location":"meta/older-releases/#v028-january-21-2022","text":"Renamed argument private to private_only in command decorator. Added two new arguments group_only and channel_only in command decorator. Added docs for command decorator. See Here","title":"v0.2.8 - January 21, 2022"},{"location":"meta/older-releases/#v027-january-21-2022","text":"Auto Update Bot Menu at runtime. Read More Added description argument in command decorator(for bot menu). Stark.data() now also returns a dictionary of command descriptions (key=command, value=description). See Stark.data Stark.activate now takes an optional argument set_menu to disable (or enable) auto-update of bot menu. Read More Added docs for Bot Menu. Read Here","title":"v0.2.7 - January 21, 2022"},{"location":"meta/older-releases/#v026-january-20-2022","text":"Added two new static methods to Stark class - Stark.list_args and Stark.data() Improved Stark.log() function. Now pass int values for levels. See Stark.log Added docs for class Stark - Read Here","title":"v0.2.6 - January 20, 2022"},{"location":"meta/older-releases/#v025-january-20-2022","text":"Added in-built functions to query postgres tables - Read More Added ChangeLog to docs (this webpage) Improve documentation using sphinx-toolbox","title":"v0.2.5 - January 20, 2022"},{"location":"meta/older-releases/#v024-january-17-2022","text":"This Documentation was created","title":"v0.2.4 - January 17, 2022"},{"location":"start/boilerplate/","text":"Generating Boilerplate PyStark comes with a command line tool to make everything even more simpler. You can easily generate a boilerplate to get started. You can also create a boilerplate with added Heroku support. Isn't that amazing? What is a boilerplate ? Boilerplate Code or Boilerplate refers to sections of code that have to be included in many places with little or no alteration. While using PyStark some code will be same for all bots. Our tool will help you to generate that much code, so you don't have to code, and it makes it easier to use PyStark. When you will generate a boilerplate using pystark, a folder with some files will be created for you. You can choose to generate a boilerplate with or without Heroku Support. For first-timers, I recommend try using without Heroku Support which can be run locally. Generating a boilerplate to run locally For generating a boilerplate for local deployment, run this command: $ pystark --boilerplate A folder named boilerplate will be created for you in that folder. Generating a boilerplate with Heroku Support For added Heroku support, run this command: $ pystark --boilerplate-heroku A folder named boilerplate will be created for you in that folder.","title":"Generating Boilerplate"},{"location":"start/boilerplate/#generating-boilerplate","text":"PyStark comes with a command line tool to make everything even more simpler. You can easily generate a boilerplate to get started. You can also create a boilerplate with added Heroku support. Isn't that amazing?","title":"Generating Boilerplate"},{"location":"start/boilerplate/#what-is-a-boilerplate","text":"Boilerplate Code or Boilerplate refers to sections of code that have to be included in many places with little or no alteration. While using PyStark some code will be same for all bots. Our tool will help you to generate that much code, so you don't have to code, and it makes it easier to use PyStark. When you will generate a boilerplate using pystark, a folder with some files will be created for you. You can choose to generate a boilerplate with or without Heroku Support. For first-timers, I recommend try using without Heroku Support which can be run locally.","title":"What is a boilerplate ?"},{"location":"start/boilerplate/#generating-a-boilerplate-to-run-locally","text":"For generating a boilerplate for local deployment, run this command: $ pystark --boilerplate A folder named boilerplate will be created for you in that folder.","title":"Generating a boilerplate to run locally"},{"location":"start/boilerplate/#generating-a-boilerplate-with-heroku-support","text":"For added Heroku support, run this command: $ pystark --boilerplate-heroku A folder named boilerplate will be created for you in that folder.","title":"Generating a boilerplate with Heroku Support"},{"location":"start/customization/","text":"Customization There are a lot of customization options in PyStark to customize the behavior of your bot. All customization options can be configured using settings.py which is generated along with boilerplate. Change the default messages PyStark comes with in-built plugins like start and help . But what if you want to have different messages than the in-built ones? They are easily customizable. You can change their values in settings.py . Change START value for /start command, HELP for /help and ABOUT for /about . Special Keywords - You may want to mention user or bot in start or help messages. You can use special keywords to do that. They will be replaced at runtime and will be different for all users. {user} - User's first name {bot} - Bot's name {user_mention} - User mention as a hyperlink {bot_mention} - Bot mention as a hyperlink {owner} - Owner mention (only works if OWNER_ID is set else @StarkBots ) So let's say your start message is set to Hi {user} and your first name on telegram is Stark then bot will send Hi Stark . Remove the default plugins PyStark comes with many in-built plugins, also called addons. By default, four of them are enabled which are start , help , about and id To remove them you need to configure ADDONS options of settings.py . To remove all addons, do this: ADDONS = [] You can also choose specific addons to configure. For example, you can enable only start and help like this: ADDONS = [ \"start\" , \"help\" , ] Rename the plugins directory You may notice that if you rename the plugins directory, the plugins won't load. To fix this you need to put the name of your plugins directory to PLUGINS option of settings.py PLUGINS = \"name of plugins folder\" Let's say you renamed the plugins folder to files . Then you should do this: PLUGINS = \"files\" Disable Bot Menu Updating Please refer here","title":"Customization"},{"location":"start/customization/#customization","text":"There are a lot of customization options in PyStark to customize the behavior of your bot. All customization options can be configured using settings.py which is generated along with boilerplate.","title":"Customization"},{"location":"start/customization/#change-the-default-messages","text":"PyStark comes with in-built plugins like start and help . But what if you want to have different messages than the in-built ones? They are easily customizable. You can change their values in settings.py . Change START value for /start command, HELP for /help and ABOUT for /about . Special Keywords - You may want to mention user or bot in start or help messages. You can use special keywords to do that. They will be replaced at runtime and will be different for all users. {user} - User's first name {bot} - Bot's name {user_mention} - User mention as a hyperlink {bot_mention} - Bot mention as a hyperlink {owner} - Owner mention (only works if OWNER_ID is set else @StarkBots ) So let's say your start message is set to Hi {user} and your first name on telegram is Stark then bot will send Hi Stark .","title":"Change the default messages"},{"location":"start/customization/#remove-the-default-plugins","text":"PyStark comes with many in-built plugins, also called addons. By default, four of them are enabled which are start , help , about and id To remove them you need to configure ADDONS options of settings.py . To remove all addons, do this: ADDONS = [] You can also choose specific addons to configure. For example, you can enable only start and help like this: ADDONS = [ \"start\" , \"help\" , ]","title":"Remove the default plugins"},{"location":"start/customization/#rename-the-plugins-directory","text":"You may notice that if you rename the plugins directory, the plugins won't load. To fix this you need to put the name of your plugins directory to PLUGINS option of settings.py PLUGINS = \"name of plugins folder\" Let's say you renamed the plugins folder to files . Then you should do this: PLUGINS = \"files\"","title":"Rename the plugins directory"},{"location":"start/customization/#disable-bot-menu-updating","text":"Please refer here","title":"Disable Bot Menu Updating"},{"location":"start/plugins/","text":"Creating Plugins Some Python knowledge is required to create plugins in general. Therefore, I highly recommend you to learn Python first. Please see this FAQ Note All plugins must be added to the plugins folder. Plugins must end with .py extension Here's a sample code for a new plugin # Import class 'Stark' in every plugin from pystark import Stark , Message # use 'Stark.cmd' decorator to create commands # @Stark.cmd('name', description=\"...\", owner_only=False, extra_filters=None, group=0, private=False) - defaults @Stark . cmd ( 'sample' , \"Sample command for bot\" ) # or @Stark.command('sample', description=\"Sample command for bot\") async def sample_function ( bot : Stark , msg : Message ): # 'msg.react()' is 'msg.reply()' with del_in added argument await msg . react ( 'This will be the reply when /sample is sent.' ) But anyway, you can create easier plugins like text plugins with no python knowledge whatsoever. from pystark import Stark @Stark . cmd ( 'command_name' , description = 'command description' ) async def text_plugin ( bot , msg ): text = 'your text here' await msg . react ( text ) For example, below plugin has a command /greet and the bot will reply with Welcome to the Bot from pystark import Stark @Stark . cmd ( 'greet' , \"Greet the user\" ) async def text_plugin ( bot , msg ): text = 'Welcome to the Bot' await msg . react ( text )","title":"Creating Plugins"},{"location":"start/plugins/#creating-plugins","text":"Some Python knowledge is required to create plugins in general. Therefore, I highly recommend you to learn Python first. Please see this FAQ Note All plugins must be added to the plugins folder. Plugins must end with .py extension Here's a sample code for a new plugin # Import class 'Stark' in every plugin from pystark import Stark , Message # use 'Stark.cmd' decorator to create commands # @Stark.cmd('name', description=\"...\", owner_only=False, extra_filters=None, group=0, private=False) - defaults @Stark . cmd ( 'sample' , \"Sample command for bot\" ) # or @Stark.command('sample', description=\"Sample command for bot\") async def sample_function ( bot : Stark , msg : Message ): # 'msg.react()' is 'msg.reply()' with del_in added argument await msg . react ( 'This will be the reply when /sample is sent.' ) But anyway, you can create easier plugins like text plugins with no python knowledge whatsoever. from pystark import Stark @Stark . cmd ( 'command_name' , description = 'command description' ) async def text_plugin ( bot , msg ): text = 'your text here' await msg . react ( text ) For example, below plugin has a command /greet and the bot will reply with Welcome to the Bot from pystark import Stark @Stark . cmd ( 'greet' , \"Greet the user\" ) async def text_plugin ( bot , msg ): text = 'Welcome to the Bot' await msg . react ( text )","title":"Creating Plugins"},{"location":"start/running-bot/","text":"Run Bot Locally You can run your bot using simple python. First go to your folder using cd Then run bot.py $ python3 bot.py You can also run your bot in any IDE like PyCharm or VS Code. Just run the bot.py file.","title":"Run Bot Locally"},{"location":"start/running-bot/#run-bot-locally","text":"You can run your bot using simple python. First go to your folder using cd Then run bot.py $ python3 bot.py You can also run your bot in any IDE like PyCharm or VS Code. Just run the bot.py file.","title":"Run Bot Locally"},{"location":"start/settings/","text":"Project Settings Your project can be customized using settings.py which is available when boilerplate is created. All available options are: PLUGINS SET_BOT_MENU CMD_PREFIXES ADDONS START HELP ABOUT MUST_JOIN TIMEZONE DATABASE_TABLES PLUGINS Path of the directory where plugins are located; in relation to the root directory. For example, if name of your directory is files and it is in the same folder as bot.py , then value of PLUGINS should be files or [\"files\"] . PLUGINS = \"files\" You can also specify multiple paths as a python list like: PLUGINS = [ \"main_plugins\" , \"other_plugins\" ] Defaults to plugins , i.e, a folder named plugins in same directory as bot.py PLUGINS = \"plugins\" SET_BOT_MENU Use this setting to enable or disable the bot menu. Read more about bot menu. Defaults to True , i.e, pystark will set the bot menu at runtime. SET_BOT_MENU = True Disable this behaviour by setting it to false SET_BOT_MENU = False CMD_PREFIXES Set the prefixes using which the commands can be called. Defaults to / . Bot will only reply to /start but not !start or #start CMD_PREFIXES = \"/\" You can change this to anything you want CMD_PREFIXES = \"!\" You can also add multiple prefixes by setting it to a python list CMD_PREFIXES = [ \"/\" , \"!\" , \"&\" ] ADDONS PyStark comes with many ready-to-use plugins which can be directly added using ADDONS option. These are the available options: start Plugin with /start command which replies with text in START option of settings.py . Only works in private chats. help Plugin with /help command which replies with text in HELP option of settings.py . Only works in private chats. about Plugin with /about command which replies with text in ABOUT option of settings.py . Only works in private chats. id Plugin with /id command which replies with user_id in private chats, chat_id and user_id in groups and channels. sudo Plugin with /sudo command which replies with all the sudo commands. json Plugin with /json command to get Message JSON of replied message and /jsondoc command to get Message JSON as document. Only owner can use these commands. must_join Force bot users to join particular chats to use the bot. Put usernames or chat ids where users must join in MUST_JOIN variable. bans Note Needs postgresql database with table bans . See DATABASE_TABLES option. Plugin with /ban command to ban people from using the bot, /unban to unban, /banlist to list banned users. broadcast Note Needs postgresql database with table users . See DATABASE_TABLES option. Plugin with /broadcast command to broadcast a message to users. stats Note Needs postgresql database with table users . See DATABASE_TABLES option. Plugin with /stats to get current user stats. By default, four addons are automatically added: ADDONS = [ \"start\" , \"help\" , \"about\" , \"id\" ] START To configure the START message, i.e, the message sent at /start command. Only needed if start addon is enabled. Default Value: START = \"Thank you for starting this bot.\" HELP To configure the HELP message, i.e, the message sent at /help command. Only needed if help addon is enabled. Default Value: HELP = \"\"\" Available Commands /start - Start the bot /help - Show this message /about - About the bot /id - Get Telegram ID \"\"\" ABOUT To configure the ABOUT message, i.e, the message sent at /about command. Only needed if about addon is enabled. Default Value: ABOUT = \"About This Bot \\n Developed using @PyStark\" MUST_JOIN List of chat ids or usernames where user must join. For example: MUST_JOIN = [ \"StarkBots\" , - 100123456789 , \"Telegram\" ] Defaults to empty list, i.e, no chat. MUST_JOIN = [] TIMEZONE Timezone to use while logging. See full list of available timezones in GitHub Gist For example: TIMEZONE = \"America/New_York\" Defaults to India, i.e, Asia/Kolkata TIMEZONE = \"Asia/Kolkata\" DATABASE_TABLES List of pre-made database tables you want to ship from PyStark. bans Tip bans addon needs a postgres table named bans with user_id and reason attributes. If you are not creating your own, you can use this one. A sqlalchemy model table bans with attributes user_id and reason . Useful for ban addon. users Tip broadcast and stats addon need a postgres table named users with user_id attribute. If you are not creating your own, you can use this one. A sqlalchemy model table users with attribute user_id . Useful for broadcast and stats addon. To enable both: DATABASE_TABLES = [ \"users\" , \"bans\" ] Defaults to empty list, i.e, no table. DATABASE_TABLES = []","title":"Project Settings"},{"location":"start/settings/#project-settings","text":"Your project can be customized using settings.py which is available when boilerplate is created. All available options are: PLUGINS SET_BOT_MENU CMD_PREFIXES ADDONS START HELP ABOUT MUST_JOIN TIMEZONE DATABASE_TABLES","title":"Project Settings"},{"location":"start/settings/#plugins","text":"Path of the directory where plugins are located; in relation to the root directory. For example, if name of your directory is files and it is in the same folder as bot.py , then value of PLUGINS should be files or [\"files\"] . PLUGINS = \"files\" You can also specify multiple paths as a python list like: PLUGINS = [ \"main_plugins\" , \"other_plugins\" ] Defaults to plugins , i.e, a folder named plugins in same directory as bot.py PLUGINS = \"plugins\"","title":"PLUGINS"},{"location":"start/settings/#set_bot_menu","text":"Use this setting to enable or disable the bot menu. Read more about bot menu. Defaults to True , i.e, pystark will set the bot menu at runtime. SET_BOT_MENU = True Disable this behaviour by setting it to false SET_BOT_MENU = False","title":"SET_BOT_MENU"},{"location":"start/settings/#cmd_prefixes","text":"Set the prefixes using which the commands can be called. Defaults to / . Bot will only reply to /start but not !start or #start CMD_PREFIXES = \"/\" You can change this to anything you want CMD_PREFIXES = \"!\" You can also add multiple prefixes by setting it to a python list CMD_PREFIXES = [ \"/\" , \"!\" , \"&\" ]","title":"CMD_PREFIXES"},{"location":"start/settings/#addons","text":"PyStark comes with many ready-to-use plugins which can be directly added using ADDONS option. These are the available options:","title":"ADDONS"},{"location":"start/settings/#start","text":"Plugin with /start command which replies with text in START option of settings.py . Only works in private chats.","title":"start"},{"location":"start/settings/#help","text":"Plugin with /help command which replies with text in HELP option of settings.py . Only works in private chats.","title":"help"},{"location":"start/settings/#about","text":"Plugin with /about command which replies with text in ABOUT option of settings.py . Only works in private chats.","title":"about"},{"location":"start/settings/#id","text":"Plugin with /id command which replies with user_id in private chats, chat_id and user_id in groups and channels.","title":"id"},{"location":"start/settings/#sudo","text":"Plugin with /sudo command which replies with all the sudo commands.","title":"sudo"},{"location":"start/settings/#json","text":"Plugin with /json command to get Message JSON of replied message and /jsondoc command to get Message JSON as document. Only owner can use these commands.","title":"json"},{"location":"start/settings/#must_join","text":"Force bot users to join particular chats to use the bot. Put usernames or chat ids where users must join in MUST_JOIN variable.","title":"must_join"},{"location":"start/settings/#bans","text":"Note Needs postgresql database with table bans . See DATABASE_TABLES option. Plugin with /ban command to ban people from using the bot, /unban to unban, /banlist to list banned users.","title":"bans"},{"location":"start/settings/#broadcast","text":"Note Needs postgresql database with table users . See DATABASE_TABLES option. Plugin with /broadcast command to broadcast a message to users.","title":"broadcast"},{"location":"start/settings/#stats","text":"Note Needs postgresql database with table users . See DATABASE_TABLES option. Plugin with /stats to get current user stats. By default, four addons are automatically added: ADDONS = [ \"start\" , \"help\" , \"about\" , \"id\" ]","title":"stats"},{"location":"start/settings/#start_1","text":"To configure the START message, i.e, the message sent at /start command. Only needed if start addon is enabled. Default Value: START = \"Thank you for starting this bot.\"","title":"START"},{"location":"start/settings/#help_1","text":"To configure the HELP message, i.e, the message sent at /help command. Only needed if help addon is enabled. Default Value: HELP = \"\"\" Available Commands /start - Start the bot /help - Show this message /about - About the bot /id - Get Telegram ID \"\"\"","title":"HELP"},{"location":"start/settings/#about_1","text":"To configure the ABOUT message, i.e, the message sent at /about command. Only needed if about addon is enabled. Default Value: ABOUT = \"About This Bot \\n Developed using @PyStark\"","title":"ABOUT"},{"location":"start/settings/#must_join_1","text":"List of chat ids or usernames where user must join. For example: MUST_JOIN = [ \"StarkBots\" , - 100123456789 , \"Telegram\" ] Defaults to empty list, i.e, no chat. MUST_JOIN = []","title":"MUST_JOIN"},{"location":"start/settings/#timezone","text":"Timezone to use while logging. See full list of available timezones in GitHub Gist For example: TIMEZONE = \"America/New_York\" Defaults to India, i.e, Asia/Kolkata TIMEZONE = \"Asia/Kolkata\"","title":"TIMEZONE"},{"location":"start/settings/#database_tables","text":"List of pre-made database tables you want to ship from PyStark.","title":"DATABASE_TABLES"},{"location":"start/settings/#bans_1","text":"Tip bans addon needs a postgres table named bans with user_id and reason attributes. If you are not creating your own, you can use this one. A sqlalchemy model table bans with attributes user_id and reason . Useful for ban addon.","title":"bans"},{"location":"start/settings/#users","text":"Tip broadcast and stats addon need a postgres table named users with user_id attribute. If you are not creating your own, you can use this one. A sqlalchemy model table users with attribute user_id . Useful for broadcast and stats addon. To enable both: DATABASE_TABLES = [ \"users\" , \"bans\" ] Defaults to empty list, i.e, no table. DATABASE_TABLES = []","title":"users"},{"location":"start/variables/","text":"Environment Variables PyStark needs some special keys as environment variables to run your bot. This section will explain how to get them and configure them. Important Never disclose API_ID , API_HASH and specially BOT_TOKEN to anyone! API_ID API_HASH BOT_TOKEN OWNER_ID API Keys API Keys are one of the most important needed keys to work with any MTProto Framework. They include a API_ID and API_HASH . You can get these from my.telegram.org Bot Token Bot Token is a specific token for every telegram bot. You will get it when you create a new bot using BotFather It should be filled as BOT_TOKEN Owner ID Your Telegram ID (or Username). Get it using Identity Bot or Rose It should be filled as OWNER_ID . Filling the Variables For Local Deploy - fill them in .env file. For Heroku Deploy - fill them after you tap on Deploy to Heroku button on your repository. Non-mandatory Variables SUDO_USERS - User IDs (or Usernames) of users that can use sudo_only commands, buttons, inline searches. Specify multiple users by adding spaces. Other Variables Necessity of these variables depends on particular use case. For example, you need DATABASE_URL only if you use sql database. You need REDIS_URL only if you use redis as your database. DATABASE_URL - needed only for PostgreSQL database REDIS_URL - needed only for Redis database (public endpoint) REDIS_PASSWORD - needed only for Redis database DB_SESSION - needed only for using Telegram as a database. DB_CHAT_ID - needed only for using Telegram as a database (ID of a new channel).","title":"Environment Variables"},{"location":"start/variables/#environment-variables","text":"PyStark needs some special keys as environment variables to run your bot. This section will explain how to get them and configure them. Important Never disclose API_ID , API_HASH and specially BOT_TOKEN to anyone! API_ID API_HASH BOT_TOKEN OWNER_ID","title":"Environment Variables"},{"location":"start/variables/#api-keys","text":"API Keys are one of the most important needed keys to work with any MTProto Framework. They include a API_ID and API_HASH . You can get these from my.telegram.org","title":"API Keys"},{"location":"start/variables/#bot-token","text":"Bot Token is a specific token for every telegram bot. You will get it when you create a new bot using BotFather It should be filled as BOT_TOKEN","title":"Bot Token"},{"location":"start/variables/#owner-id","text":"Your Telegram ID (or Username). Get it using Identity Bot or Rose It should be filled as OWNER_ID .","title":"Owner ID"},{"location":"start/variables/#filling-the-variables","text":"For Local Deploy - fill them in .env file. For Heroku Deploy - fill them after you tap on Deploy to Heroku button on your repository.","title":"Filling the Variables"},{"location":"start/variables/#non-mandatory-variables","text":"SUDO_USERS - User IDs (or Usernames) of users that can use sudo_only commands, buttons, inline searches. Specify multiple users by adding spaces.","title":"Non-mandatory Variables"},{"location":"start/variables/#other-variables","text":"Necessity of these variables depends on particular use case. For example, you need DATABASE_URL only if you use sql database. You need REDIS_URL only if you use redis as your database. DATABASE_URL - needed only for PostgreSQL database REDIS_URL - needed only for Redis database (public endpoint) REDIS_PASSWORD - needed only for Redis database DB_SESSION - needed only for using Telegram as a database. DB_CHAT_ID - needed only for using Telegram as a database (ID of a new channel).","title":"Other Variables"},{"location":"topics/bot-menu/","text":"Bot Menu Telegram has a feature to create a bot menu for your bot. It's usually created using BotFather. It looks like this: But it's exhausting to keep updating it using BotFather. Why not let pystark generate it for you automatically at runtime? But How to Do That? It's very easy. Just add command description when you create a function. Like this: from pystark import Stark @Stark . command ( 'stats' , description = 'Get the bot stats' ) def stats (): # your code Or a more simple look: from pystark import Stark @Stark . cmd ( 'stats' , 'Get the bot stats' ) def stats (): # your code Don't want users to see a command in menu? Then don't pass it. from pystark import Stark @Stark . cmd ( 'stats' ) # no description def stats (): # your code Note Menu will be automatically updated when you start the bot. It will be automatically removed when you stop the bot. Prevent pystark from updating bot menu By default, this feature is enabled. But what if you don't want it? You need to configure SET_BOT_MENU option of settings.py You will see something like this: SET_BOT_MENU = True Change it to this: SET_BOT_MENU = False","title":"Bot Menu"},{"location":"topics/bot-menu/#bot-menu","text":"Telegram has a feature to create a bot menu for your bot. It's usually created using BotFather. It looks like this: But it's exhausting to keep updating it using BotFather. Why not let pystark generate it for you automatically at runtime? But How to Do That? It's very easy. Just add command description when you create a function. Like this: from pystark import Stark @Stark . command ( 'stats' , description = 'Get the bot stats' ) def stats (): # your code Or a more simple look: from pystark import Stark @Stark . cmd ( 'stats' , 'Get the bot stats' ) def stats (): # your code Don't want users to see a command in menu? Then don't pass it. from pystark import Stark @Stark . cmd ( 'stats' ) # no description def stats (): # your code Note Menu will be automatically updated when you start the bot. It will be automatically removed when you stop the bot. Prevent pystark from updating bot menu By default, this feature is enabled. But what if you don't want it? You need to configure SET_BOT_MENU option of settings.py You will see something like this: SET_BOT_MENU = True Change it to this: SET_BOT_MENU = False","title":"Bot Menu"},{"location":"topics/class-stark/","text":"Class Stark This is the main class of PyStark. This guide will explain the usage of important functions in Stark class. activate ( self ) Main method of Stark class which loads plugins and activates/runs your bot. data ( key = None ) staticmethod Returns a special dictionary with five keys. Key Returns plugins number of plugins in bot plugins_list list of plugins in bot commands number of commands in bot commands_list list of commands in bot command_descriptions dictionary of command and their descriptions if passed in Stark.cmd decorator Parameters: Name Type Description Default key str, optional) If you want to get only one of the five keys from [\"plugins\", \"plugins_list\", \"commands\", \"commands_list\", \"command_descriptions\"] None Examples: { \"plugins\" : 2 , \"plugins_list\" : [ \"basic\" , \"sample\" ], \"commands\" : 5 , \"command_list\" : [ \"start\" , \"help\" , \"about\" , \"id\" , \"sample\" ]}, command_descriptions : { \"start\" : \"Start the bot\" } list_args ( message , split = ' ' ) staticmethod List arguments passed in a message. Removes first word (the command itself) Parameters: Name Type Description Default message pystark.Message Pass a command message or message.text to get arguments passed in this message. required split str Define how to split the arguments, defaults to whitespace. ' ' Examples: If text is /start reply user , return value would be [\"reply\", \"user\"] list_modules ( directory ) staticmethod List all modules in a directory load_modules ( self , plugins ) Load all modules from a directory or a single module as pyrogram handlers log ( message , level = 20 ) staticmethod Log messages to console. String Integer debug 10 info 20 warning 30 error 40 critical 50 Parameters: Name Type Description Default message Any Item to print to console. required level optional Logging level as string or int. 20 run ( self ) Alias of Stark.activate()","title":"Class Stark"},{"location":"topics/class-stark/#class-stark","text":"This is the main class of PyStark. This guide will explain the usage of important functions in Stark class.","title":"Class Stark"},{"location":"topics/class-stark/#pystark.client.Stark.activate","text":"Main method of Stark class which loads plugins and activates/runs your bot.","title":"activate()"},{"location":"topics/class-stark/#pystark.client.Stark.data","text":"Returns a special dictionary with five keys. Key Returns plugins number of plugins in bot plugins_list list of plugins in bot commands number of commands in bot commands_list list of commands in bot command_descriptions dictionary of command and their descriptions if passed in Stark.cmd decorator Parameters: Name Type Description Default key str, optional) If you want to get only one of the five keys from [\"plugins\", \"plugins_list\", \"commands\", \"commands_list\", \"command_descriptions\"] None Examples: { \"plugins\" : 2 , \"plugins_list\" : [ \"basic\" , \"sample\" ], \"commands\" : 5 , \"command_list\" : [ \"start\" , \"help\" , \"about\" , \"id\" , \"sample\" ]}, command_descriptions : { \"start\" : \"Start the bot\" }","title":"data()"},{"location":"topics/class-stark/#pystark.client.Stark.list_args","text":"List arguments passed in a message. Removes first word (the command itself) Parameters: Name Type Description Default message pystark.Message Pass a command message or message.text to get arguments passed in this message. required split str Define how to split the arguments, defaults to whitespace. ' ' Examples: If text is /start reply user , return value would be [\"reply\", \"user\"]","title":"list_args()"},{"location":"topics/class-stark/#pystark.client.Stark.list_modules","text":"List all modules in a directory","title":"list_modules()"},{"location":"topics/class-stark/#pystark.client.Stark.load_modules","text":"Load all modules from a directory or a single module as pyrogram handlers","title":"load_modules()"},{"location":"topics/class-stark/#pystark.client.Stark.log","text":"Log messages to console. String Integer debug 10 info 20 warning 30 error 40 critical 50 Parameters: Name Type Description Default message Any Item to print to console. required level optional Logging level as string or int. 20","title":"log()"},{"location":"topics/class-stark/#pystark.client.Stark.run","text":"Alias of Stark.activate()","title":"run()"},{"location":"topics/postgres/","text":"Querying Postgres Tables In this guide, you will learn how to query using postgres tables while using PyStark Tip No need to add sqlalchemy or psycopg2 to requirement.txt as they are dependencies of pystark Using the in-built functions PyStark provides some default functions to query postgres tables. These functions allow you to query tables using table name ( __tablename__ attribute), that is, a string instead of a class. Therefore, you do not need to import classes. Note All the in-built functions are asynchronous and use raw sql. First thing you need to do is creating an instance of Database class Tip It's a good idea to create this instance in a separate module so that it's easily importable. from pystark.database.sql import Database db = Database () Now you can call other functions. Name Function all Get All Rows get Get a Particular Row count Get Number of Rows set Set/Update value of a key in a Row delete Delete a Row Get All Rows # Get all rows from \"users\" table as dicts. async def get_users (): all_data = await db . get_all_data ( \"users\" ) # or await db.all(\"users\") print ( all_data ) Get a Particular Row # Get row using primary key from \"users\" table. async def get_user (): user_id = 500123456 # primary key get_data = await db . get ( \"users\" , user_id ) print ( get_data ) Get Number of Rows # Get number of rows in \"users\" table. async def user_count (): count = await db . count ( \"users\" ) print ( count ) Set/Update value of a key in a Row # set/update key, value pairs in \"users\" table. async def set_data (): user_id = 500123456 # primary key key_to_change = \"aim\" new_value = \"programmer\" await db . set ( \"users\" , user_id , key_to_change , new_value ) print ( \"Set\" ) Delete a Row # Delete a row using primary key from \"users\" table. async def delete_user (): user_id = 500123456 delete_data = await db . delete ( \"users\" , user_id ) print ( \"Deleted\" ) Using the Regular Way (Session object) You can query tables using the session object which is the regular way in sqlalchemy. Session objects is available as an attribute to Database class of pystark.database.sql # import 'Session' object from pystark.database.sql import Database # import Python class for respective table # let's say it is in 'users_sql.py' inside 'database' folder. from database.users_sql import Users db = Database () # This function gives total 'rows', that is total user ids in 'users' table. def num_users (): users = db . session . query ( Users ) . count () # close session after all queries are made. db . session . close () return users # This function returns 'name' and 'aim' for users by using 'user_id' def get_name_and_aim ( user_id ): query = db . session . query ( Users ) . get ( user_id ) name = query . name # get name aim = query . aim # get aim db . session . close () return ( name , aim ) # This function sets name and aim for users by using 'user_id' def set_name_and_aim ( user_id , name , aim ): query = db . session . query ( Users ) . get ( user_id ) query . name = name # set name query . aim = aim # set aim db . session . commit () # use this after setting anything. # Now you don't need to 'db.session.close()' as you used 'db.session.commit()' already. # Etc","title":"Querying Postgres Tables"},{"location":"topics/postgres/#querying-postgres-tables","text":"In this guide, you will learn how to query using postgres tables while using PyStark Tip No need to add sqlalchemy or psycopg2 to requirement.txt as they are dependencies of pystark","title":"Querying Postgres Tables"},{"location":"topics/postgres/#using-the-in-built-functions","text":"PyStark provides some default functions to query postgres tables. These functions allow you to query tables using table name ( __tablename__ attribute), that is, a string instead of a class. Therefore, you do not need to import classes. Note All the in-built functions are asynchronous and use raw sql. First thing you need to do is creating an instance of Database class Tip It's a good idea to create this instance in a separate module so that it's easily importable. from pystark.database.sql import Database db = Database () Now you can call other functions. Name Function all Get All Rows get Get a Particular Row count Get Number of Rows set Set/Update value of a key in a Row delete Delete a Row Get All Rows # Get all rows from \"users\" table as dicts. async def get_users (): all_data = await db . get_all_data ( \"users\" ) # or await db.all(\"users\") print ( all_data ) Get a Particular Row # Get row using primary key from \"users\" table. async def get_user (): user_id = 500123456 # primary key get_data = await db . get ( \"users\" , user_id ) print ( get_data ) Get Number of Rows # Get number of rows in \"users\" table. async def user_count (): count = await db . count ( \"users\" ) print ( count ) Set/Update value of a key in a Row # set/update key, value pairs in \"users\" table. async def set_data (): user_id = 500123456 # primary key key_to_change = \"aim\" new_value = \"programmer\" await db . set ( \"users\" , user_id , key_to_change , new_value ) print ( \"Set\" ) Delete a Row # Delete a row using primary key from \"users\" table. async def delete_user (): user_id = 500123456 delete_data = await db . delete ( \"users\" , user_id ) print ( \"Deleted\" )","title":"Using the in-built functions"},{"location":"topics/postgres/#using-the-regular-way-session-object","text":"You can query tables using the session object which is the regular way in sqlalchemy. Session objects is available as an attribute to Database class of pystark.database.sql # import 'Session' object from pystark.database.sql import Database # import Python class for respective table # let's say it is in 'users_sql.py' inside 'database' folder. from database.users_sql import Users db = Database () # This function gives total 'rows', that is total user ids in 'users' table. def num_users (): users = db . session . query ( Users ) . count () # close session after all queries are made. db . session . close () return users # This function returns 'name' and 'aim' for users by using 'user_id' def get_name_and_aim ( user_id ): query = db . session . query ( Users ) . get ( user_id ) name = query . name # get name aim = query . aim # get aim db . session . close () return ( name , aim ) # This function sets name and aim for users by using 'user_id' def set_name_and_aim ( user_id , name , aim ): query = db . session . query ( Users ) . get ( user_id ) query . name = name # set name query . aim = aim # set aim db . session . commit () # use this after setting anything. # Now you don't need to 'db.session.close()' as you used 'db.session.commit()' already. # Etc","title":"Using the Regular Way (Session object)"},{"location":"topics/telegram-as-database/","text":"Using Telegram as a Database You can use Telegram as a Database, thanks to TelegramDB . Note This feature is still in beta and this is just a pre-release. Needed Variables DB_SESSION - String Session for a Telegram account. DB_CHAT_ID - Create a new telegram channel for database. Set Telegram ID for that channel as this. What is a DataPack? Like there are Tables in SQL, TelegramDB has DataPacks. It is just a fancy term to scare you. Create a DataPack from pystark import Stark from pystark.database.telegram_db import DataPack , Member , Session # Create a DataPack like you create a Table in Postgres (SQLAlchemy). class TestData ( DataPack ): __datapack_name__ = \"test\" id = Member ( int , is_primary = True ) name = Member ( str ) aim = Member ( str ) def __init__ ( self , id , name = None , aim = None ): self . id = id self . name = name self . aim = aim Session . prepare_datapack ( TestData ) Query a DataPack # Import Session object from pystark from pystark.database.telegram_db import Session # \"test_data.py\" is a file in \"database\" folder, where class TestData is located. from database.test_data import TestData # Commit to DataPack. test = TestData ( 1 , name = \"Stark\" , aim = \"Create Time Machine\" ) Session . commit ( test ) # Get info from DataPack. user = TestData ( 1 ) # pass primary key. if Session . get ( user ): print ( \"User exists!\" ) print ( \"ID: \" , user . id ) print ( \"Name: \" , user . name ) print ( \"Aim: \" , user . aim ) else : print ( \"No user with ID: 1\" ) Load DataPacks and Enable Telegram DB After adding variables specified above, you need to create datapack(s) using Python Classes . For a datapack to be loaded, you need to import it in some plugin. Also, you obviously you need to import it to use it anyway. Example: # Let's say I've a file named `a.py` with class `DataPack1`. # This file is located in a folder named `dbs` in same directory as 'bot.py'. from dbs.a import DataPack1 This will enable the database and load DataPack1 named datapack.","title":"Using Telegram as a Database"},{"location":"topics/telegram-as-database/#using-telegram-as-a-database","text":"You can use Telegram as a Database, thanks to TelegramDB . Note This feature is still in beta and this is just a pre-release.","title":"Using Telegram as a Database"},{"location":"topics/telegram-as-database/#needed-variables","text":"DB_SESSION - String Session for a Telegram account. DB_CHAT_ID - Create a new telegram channel for database. Set Telegram ID for that channel as this.","title":"Needed Variables"},{"location":"topics/telegram-as-database/#what-is-a-datapack","text":"Like there are Tables in SQL, TelegramDB has DataPacks. It is just a fancy term to scare you.","title":"What is a DataPack?"},{"location":"topics/telegram-as-database/#create-a-datapack","text":"from pystark import Stark from pystark.database.telegram_db import DataPack , Member , Session # Create a DataPack like you create a Table in Postgres (SQLAlchemy). class TestData ( DataPack ): __datapack_name__ = \"test\" id = Member ( int , is_primary = True ) name = Member ( str ) aim = Member ( str ) def __init__ ( self , id , name = None , aim = None ): self . id = id self . name = name self . aim = aim Session . prepare_datapack ( TestData )","title":"Create a DataPack"},{"location":"topics/telegram-as-database/#query-a-datapack","text":"# Import Session object from pystark from pystark.database.telegram_db import Session # \"test_data.py\" is a file in \"database\" folder, where class TestData is located. from database.test_data import TestData # Commit to DataPack. test = TestData ( 1 , name = \"Stark\" , aim = \"Create Time Machine\" ) Session . commit ( test ) # Get info from DataPack. user = TestData ( 1 ) # pass primary key. if Session . get ( user ): print ( \"User exists!\" ) print ( \"ID: \" , user . id ) print ( \"Name: \" , user . name ) print ( \"Aim: \" , user . aim ) else : print ( \"No user with ID: 1\" )","title":"Query a DataPack"},{"location":"topics/telegram-as-database/#load-datapacks-and-enable-telegram-db","text":"After adding variables specified above, you need to create datapack(s) using Python Classes . For a datapack to be loaded, you need to import it in some plugin. Also, you obviously you need to import it to use it anyway. Example: # Let's say I've a file named `a.py` with class `DataPack1`. # This file is located in a folder named `dbs` in same directory as 'bot.py'. from dbs.a import DataPack1 This will enable the database and load DataPack1 named datapack.","title":"Load DataPacks and Enable Telegram DB"},{"location":"topics/tinydb/","text":"Using TinyDB TinyDB is a simple json-based database which does not need anything externally. You don't need to have a Database URL for it, and you can add unlimited data. When to use TinyDB? It's recommended to use TinyDB during these situations. If you: are a beginner and need a simple database. are deploying your bot locally. have a small project. don't care that much about speed and performance. Though you won't see much difference in small projects. How to Initialize TinyDB? Note Don't forget to add tinydb to requirement.txt Here's how to initialize TinyDB # import db object from pystark from pystark.database.tiny_db import db , Query # or create a db object yourself from tinydb import TinyDB , Query db = TinyDB ( 'db.json' ) How to Query TinyDB? Insert Data from pystark.database.tiny_db import db # just pass a python dictionary to insert() function. db . insert ({ 'type' : 'apple' , 'count' : 7 }) db . insert ({ 'name' : 'Stark' , 'aim' : 'Meet God' }) Search/Query Data from pystark.database.tiny_db import db # Along with db object, you need Query object too. # import Query object from pystark or tinydb from pystark.database.tiny_db import Query # or from tinydb import Query Fruit = Query () data = db . search ( Fruit . type == 'apple' ) User = Query () data = db . search ( User . name == 'Stark' ) Remove/Delete Data from pystark.database.tiny_db import db , Query Fruit = Query () data = db . remove ( Fruit . type == 'apple' ) User = Query () data = db . remove ( User . name == 'Stark' ) Update Data from pystark.database.tiny_db import db , Query Fruit = Query () data = db . update ({ 'count' : 10 }, Fruit . type == 'apple' ) User = Query () data = db . update ({ 'aim' : 'Create Time Machine' }, User . name == 'Stark' ) Get all Data db . all () Get all Tables db . tables () Number of Tables db . tables_count () Delete all Data / Empty the Database db . truncate ()","title":"Using TinyDB"},{"location":"topics/tinydb/#using-tinydb","text":"TinyDB is a simple json-based database which does not need anything externally. You don't need to have a Database URL for it, and you can add unlimited data.","title":"Using TinyDB"},{"location":"topics/tinydb/#when-to-use-tinydb","text":"It's recommended to use TinyDB during these situations. If you: are a beginner and need a simple database. are deploying your bot locally. have a small project. don't care that much about speed and performance. Though you won't see much difference in small projects.","title":"When to use TinyDB?"},{"location":"topics/tinydb/#how-to-initialize-tinydb","text":"Note Don't forget to add tinydb to requirement.txt Here's how to initialize TinyDB # import db object from pystark from pystark.database.tiny_db import db , Query # or create a db object yourself from tinydb import TinyDB , Query db = TinyDB ( 'db.json' )","title":"How to Initialize TinyDB?"},{"location":"topics/tinydb/#how-to-query-tinydb","text":"Insert Data from pystark.database.tiny_db import db # just pass a python dictionary to insert() function. db . insert ({ 'type' : 'apple' , 'count' : 7 }) db . insert ({ 'name' : 'Stark' , 'aim' : 'Meet God' }) Search/Query Data from pystark.database.tiny_db import db # Along with db object, you need Query object too. # import Query object from pystark or tinydb from pystark.database.tiny_db import Query # or from tinydb import Query Fruit = Query () data = db . search ( Fruit . type == 'apple' ) User = Query () data = db . search ( User . name == 'Stark' ) Remove/Delete Data from pystark.database.tiny_db import db , Query Fruit = Query () data = db . remove ( Fruit . type == 'apple' ) User = Query () data = db . remove ( User . name == 'Stark' ) Update Data from pystark.database.tiny_db import db , Query Fruit = Query () data = db . update ({ 'count' : 10 }, Fruit . type == 'apple' ) User = Query () data = db . update ({ 'aim' : 'Create Time Machine' }, User . name == 'Stark' ) Get all Data db . all () Get all Tables db . tables () Number of Tables db . tables_count () Delete all Data / Empty the Database db . truncate ()","title":"How to Query TinyDB?"},{"location":"topics/using-databases/","text":"Using Databases You can use any database you wish with PyStark, but we have provided a simple default setup for some databases, such as PostgreSQL and Redis, to make them even easier to use. By following this guide, you will have a basic understanding of how to use them. TinyDB TinyDB is a simple database which does not require a Database URL and is very simple. If you are a beginner, it is for you. Read How to Use It . PostgreSQL (using sqlalchemy) Database URL - You need to add DATABASE_URL to .env . If you are using Heroku boilerplate, leave it to Heroku and pystark . Otherwise, you can get a Database URL from ElephantSQL Creating Tables - You need to create all the tables with all columns you need. In Python, using Classes. Below is a code example for a table named users with 3 columns named user_id , name , and aim : # Import class 'Database' from pystark from pystark.database.sql import Database # Import basic sqlalchemy classes from sqlalchemy import Column , Integer , String # create a database instance db = Database () # Every class should inherit from 'db.base' class Users ( db . base ): __tablename__ = \"users\" __table_args__ = { 'extend_existing' : True } user_id = Column ( Integer , primary_key = True ) # sql primary key (pk) name = Column ( String ) aim = Column ( String ) def __init__ ( self , user_id , name , aim = None ): self . user_id = user_id self . name = name self . aim = aim # Create Table Users . __table__ . create ( checkfirst = True ) Querying Tables - You can query tables using Session object or the in-built pystark functions. Using Session object Using in-built functions Using Telegram as a Database You can use Telegram as a Database, thanks to this project . But How? - Read Documentation Here Redis (using redis-py) Variables - You need to set REDIS_URL (public endpoint) and REDIS_PASSWORD by creating a database at redislabs.com Setting and Getting key-value pairs from pystark.database.redis_db import redis redis . set ( 'Agra' , 'Taj Mahal' ) redis . get ( 'Agra' ) b 'Taj Mahal' MongoDB Coming soon.","title":"Using Databases"},{"location":"topics/using-databases/#using-databases","text":"You can use any database you wish with PyStark, but we have provided a simple default setup for some databases, such as PostgreSQL and Redis, to make them even easier to use. By following this guide, you will have a basic understanding of how to use them.","title":"Using Databases"},{"location":"topics/using-databases/#tinydb","text":"TinyDB is a simple database which does not require a Database URL and is very simple. If you are a beginner, it is for you. Read How to Use It .","title":"TinyDB"},{"location":"topics/using-databases/#postgresql-using-sqlalchemy","text":"Database URL - You need to add DATABASE_URL to .env . If you are using Heroku boilerplate, leave it to Heroku and pystark . Otherwise, you can get a Database URL from ElephantSQL Creating Tables - You need to create all the tables with all columns you need. In Python, using Classes. Below is a code example for a table named users with 3 columns named user_id , name , and aim : # Import class 'Database' from pystark from pystark.database.sql import Database # Import basic sqlalchemy classes from sqlalchemy import Column , Integer , String # create a database instance db = Database () # Every class should inherit from 'db.base' class Users ( db . base ): __tablename__ = \"users\" __table_args__ = { 'extend_existing' : True } user_id = Column ( Integer , primary_key = True ) # sql primary key (pk) name = Column ( String ) aim = Column ( String ) def __init__ ( self , user_id , name , aim = None ): self . user_id = user_id self . name = name self . aim = aim # Create Table Users . __table__ . create ( checkfirst = True ) Querying Tables - You can query tables using Session object or the in-built pystark functions. Using Session object Using in-built functions","title":"PostgreSQL (using sqlalchemy)"},{"location":"topics/using-databases/#using-telegram-as-a-database","text":"You can use Telegram as a Database, thanks to this project . But How? - Read Documentation Here","title":"Using Telegram as a Database"},{"location":"topics/using-databases/#redis-using-redis-py","text":"Variables - You need to set REDIS_URL (public endpoint) and REDIS_PASSWORD by creating a database at redislabs.com Setting and Getting key-value pairs from pystark.database.redis_db import redis redis . set ( 'Agra' , 'Taj Mahal' ) redis . get ( 'Agra' ) b 'Taj Mahal'","title":"Redis (using redis-py)"},{"location":"topics/using-databases/#mongodb","text":"Coming soon.","title":"MongoDB"}]}